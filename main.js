// Generated by CoffeeScript 1.7.1
var ASPECT, FAR, HEIGHT, NEAR, T, VIEW_ANGLE, WIDTH, animate, camera, canvas, canvases, controls, ctx, dimensions, faceMaterial, groundMirror, i, light, map, materials, mirrorMesh, mouse, planeGeom, product, productGeometry, renderer, scene, shape, skyBox, skyBoxGeometry, skyBoxMaterial, unprojector, update_size;

T = THREE;

scene = new T.Scene();

WIDTH = window.innerWidth;

HEIGHT = window.innerHeight;

ASPECT = WIDTH / HEIGHT;

VIEW_ANGLE = 45;

NEAR = 0.1;

FAR = 20000;

camera = new T.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

scene.add(camera);

camera.position.set(0, 150, 400);

camera.lookAt(scene.position);

renderer = Detector.webgl ? new T.WebGLRenderer({
  antialias: true
}) : new T.CanvasRenderer();

renderer.setSize(WIDTH, HEIGHT);

document.body.appendChild(renderer.domElement);

$(window).on('resize', function() {
  WIDTH = window.innerWidth;
  HEIGHT = window.innerHeight;
  ASPECT = WIDTH / HEIGHT;
  renderer.setSize(WIDTH, HEIGHT);
  camera.aspect = ASPECT;
  return camera.updateProjectionMatrix();
});

controls = new T.OrbitControls(camera, renderer.domElement);

light = new T.AmbientLight(0xffffff);

scene.add(light);

skyBoxGeometry = new T.BoxGeometry(10000, 10000, 10000);

skyBoxMaterial = new T.MeshBasicMaterial({
  color: 0x000000,
  side: T.BackSide
});

skyBox = new T.Mesh(skyBoxGeometry, skyBoxMaterial);

scene.add(skyBox);

canvases = (function() {
  var _i, _results;
  _results = [];
  for (i = _i = 0; _i <= 6; i = ++_i) {
    canvas = document.createElement('canvas');
    canvas.width = canvas.height = 1024;
    ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ddd';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 5;
    ctx.strokeStyle = '#000';
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    _results.push(canvas);
  }
  return _results;
})();

materials = (function() {
  var _i, _len, _results;
  _results = [];
  for (_i = 0, _len = canvases.length; _i < _len; _i++) {
    canvas = canvases[_i];
    map = new T.Texture(canvas);
    map.needsUpdate = true;
    _results.push(new T.MeshLambertMaterial({
      side: T.FrontSide,
      map: map
    }));
  }
  return _results;
})();

faceMaterial = new T.MeshFaceMaterial(materials);

productGeometry = product = null;

planeGeom = new THREE.PlaneGeometry(10000.1, 10000.1);

groundMirror = new THREE.Mirror(renderer, camera, {
  clipBias: 0.003,
  textureWidth: WIDTH,
  textureHeight: HEIGHT,
  color: 0x101010
});

mirrorMesh = new THREE.Mesh(planeGeom, groundMirror.material);

mirrorMesh.add(groundMirror);

mirrorMesh.rotateX(-Math.PI / 2);

mirrorMesh.position.set(0, -114, 0);

scene.add(mirrorMesh);

unprojector = new T.Projector();

mouse = {
  x: 0,
  y: 0
};

$('body').on('mousemove dragover dragenter drop', function(e) {
  var dt, file, fr, intersect, intersects, mid, ray, vector, _i, _len, _ref, _ref1, _results;
  e.preventDefault();
  mouse.x = (e.originalEvent.offsetX / WIDTH) * 2 - 1;
  mouse.y = (e.originalEvent.offsetY / HEIGHT) * -2 + 1;
  vector = new T.Vector3(mouse.x, mouse.y, 1);
  unprojector.unprojectVector(vector, camera);
  ray = new T.Raycaster(camera.position, vector.sub(camera.position).normalize());
  intersects = ray.intersectObjects([product]);
  if (mouse.intersect) {
    mid = mouse.intersect.face.materialIndex;
    materials[mid].emissive.setHex(0x000000);
    materials[mid].needsUpdate = true;
  }
  mouse.intersect = intersect = intersects[0];
  if (mouse.intersect && e.type !== 'mousemove') {
    mid = intersect.face.materialIndex;
    materials[mid].emissive.setHex(0xa0a0a0);
    materials[mid].needsUpdate = true;
    dt = e.originalEvent.dataTransfer;
    if (e.type === 'drop' && (dt != null ? (_ref = dt.files) != null ? _ref.length : void 0 : void 0)) {
      _ref1 = dt.files;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        if (file.type.match(/image/)) {
          fr = new FileReader();
          fr.onload = function() {
            materials[mid].map = T.ImageUtils.loadTexture(fr.result);
            materials[mid].needsUpdate = true;
            return intersect.object.geometry.needsUpdate = true;
          };
          _results.push(fr.readAsDataURL(file));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  }
});

dimensions = {
  x: 1,
  y: 1,
  z: 1,
  r: 1,
  h: 1
};

shape = "box" || "cylinder";

update_size = function() {
  var s;
  s = 10;
  switch (shape) {
    case "box":
      product.scale.x = dimensions.x * s;
      product.scale.y = dimensions.y * s;
      product.scale.z = dimensions.z * s;
      return mirrorMesh.position.set(0, -(dimensions.y * s / 2 + 4.23), 0);
    case "cylinder":
      product.scale.x = dimensions.r * s;
      product.scale.y = dimensions.h * s;
      product.scale.z = dimensions.r * s;
      return mirrorMesh.position.set(0, -(dimensions.h * s / 2 + 4.23), 0);
  }
};

$('input').each(function(i) {
  var d;
  d = 'xyzrh'[i];
  return $(this).on('change', function() {
    dimensions[d] = $(this).val();
    return update_size();
  });
});

$('select#template').on('change', function() {
  shape = $(this).val();
  switch (shape) {
    case "box":
      productGeometry = new T.BoxGeometry(1, 1, 1, 10, 10, 10);
      $('#cuboid-dimensions').show();
      $('#cylindrical-dimensions').hide();
      break;
    case "cylinder":
      productGeometry = new T.CylinderGeometry(1, 1, 1, 25, 25, false);
      $('#cuboid-dimensions').hide();
      $('#cylindrical-dimensions').show();
  }
  if (product) {
    scene.remove(product);
  }
  product = new T.Mesh(productGeometry, faceMaterial);
  scene.add(product);
  return update_size();
});

(animate = function() {
  requestAnimationFrame(animate);
  groundMirror.render();
  renderer.render(scene, camera);
  return controls.update();
})();

$('select').trigger('change');

$('input').trigger('change');

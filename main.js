// Generated by CoffeeScript 1.6.3
var ASPECT, FAR, HEIGHT, NEAR, VIEW_ANGLE, WIDTH, animate, camera, controls, face, faceMaterial, i, light, materials, mouse, product, productGeometry, projector, renderer, scene, skyBox, skyBoxGeometry, skyBoxMaterial, _i, _len, _ref;

mouse = {
  x: 0,
  y: 0
};

scene = new THREE.Scene();

WIDTH = window.innerWidth;

HEIGHT = window.innerHeight;

ASPECT = WIDTH / HEIGHT;

VIEW_ANGLE = 45;

NEAR = 0.1;

FAR = 20000;

camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

scene.add(camera);

camera.position.set(0, 150, 400);

camera.lookAt(scene.position);

renderer = Detector.webgl ? new THREE.WebGLRenderer({
  antialias: true
}) : new THREE.CanvasRenderer();

renderer.setSize(WIDTH, HEIGHT);

document.body.appendChild(renderer.domElement);

$(window).on("resize", function() {
  WIDTH = window.innerWidth;
  HEIGHT = window.innerHeight;
  ASPECT = WIDTH / HEIGHT;
  renderer.setSize(WIDTH, HEIGHT);
  camera.aspect = ASPECT;
  return camera.updateProjectionMatrix();
});

controls = new THREE.OrbitControls(camera, renderer.domElement);

light = new THREE.AmbientLight(0xaaaaa);

scene.add(light);

light = new THREE.PointLight(0xffffff);

light.position.set(-25, 250, -78);

scene.add(light);

light = new THREE.PointLight(0x00ffff);

light.position.set(225, 250, -98);

scene.add(light);

light = new THREE.PointLight(0xff00ff);

light.position.set(255, -25, 97);

scene.add(light);

/*
floorTexture = new THREE.ImageUtils.loadTexture 'images/checkerboard.jpg'
floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping 
floorTexture.repeat.set(10, 10)
floorMaterial = new THREE.MeshBasicMaterial(map: floorTexture, side: THREE.DoubleSide)
floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10)
floor = new THREE.Mesh(floorGeometry, floorMaterial)
floor.position.y = -0.5
floor.rotation.x = Math.PI / 2
scene.add(floor)
*/


skyBoxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);

skyBoxMaterial = new THREE.MeshBasicMaterial({
  color: 0x000000,
  side: THREE.BackSide
});

skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);

scene.add(skyBox);

materials = (function() {
  var _i, _results;
  _results = [];
  for (i = _i = 0; _i <= 6; i = ++_i) {
    _results.push(new THREE.MeshLambertMaterial({
      color: 0xffffff
    }));
  }
  return _results;
})();

faceMaterial = new THREE.MeshFaceMaterial(materials);

productGeometry = new THREE.CubeGeometry(180, 220, 50);

_ref = productGeometry.faces;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  face = _ref[_i];
  face.color.setRGB(0, 0, 0.8 * Math.random() + 0.2);
}

product = new THREE.Mesh(productGeometry, faceMaterial);

product.position.set(0, 0, 0);

scene.add(product);

projector = new THREE.Projector();

$(renderer.domElement).on("mousemove", function(e) {
  var intersects, ray, vector;
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = (e.clientY / window.innerHeight) * -2 + 1;
  vector = new THREE.Vector3(mouse.x, mouse.y, 1);
  projector.unprojectVector(vector, camera);
  ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
  intersects = ray.intersectObjects([product]);
  return mouse.intersect = intersects[0];
});

$("body").on("dragover dragenter drop", function(e) {
  var dt, file, fr, intersect, _j, _len1, _ref1, _ref2, _results;
  e.preventDefault();
  dt = e.originalEvent.dataTransfer;
  intersect = mouse.intersect;
  console.log(e.type);
  if (intersect && (dt != null ? (_ref1 = dt.files) != null ? _ref1.length : void 0 : void 0)) {
    console.log("dropped file on box");
    _ref2 = dt.files;
    _results = [];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      file = _ref2[_j];
      if (file.type.match(/image/)) {
        fr = new FileReader();
        fr.onload = function() {
          var mid;
          mid = intersect.face.materialIndex;
          materials[mid].map = THREE.ImageUtils.loadTexture(fr.result);
          return materials[mid].needsUpdate = true;
        };
        _results.push(fr.readAsDataURL(file));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  }
});

(animate = function() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
  return controls.update();
})();

/*
//@ sourceMappingURL=main.map
*/
